// This file is auto-generated by @hey-api/openapi-ts
// @ts-nocheck

import { type Options, inviteControllerGetInvitesForCourseVersion, inviteControllerInviteUsers, inviteControllerProcessInvites, inviteControllerResendInvite, inviteControllerCancelInvite, enrollmentControllerGetEnrollment, enrollmentControllerEnrollUser, enrollmentControllerUnenrollUser, enrollmentControllerGetUserEnrollments, enrollmentControllerGetCourseVersionEnrollments, progressControllerGetUserProgress, progressControllerGetUserProgressPercentage, progressControllerStartItem, progressControllerStopItem, progressControllerUpdateProgress, progressControllerResetProgress, progressControllerGetWatchTime, userControllerGetUserById, userControllerEditUser, userControllerMakeAdmin, authControllerSignup, authControllerGoogleSignup, authControllerChangePassword, authControllerLogin, courseControllerCreate, courseControllerDelete, courseControllerRead, courseControllerUpdate, courseVersionControllerCreate, courseVersionControllerRead, courseVersionControllerDelete, itemControllerReadAll, itemControllerCreate, itemControllerUpdate, itemControllerDelete, itemControllerMove, itemControllerGetItem, moduleControllerCreate, moduleControllerDelete, moduleControllerUpdate, moduleControllerMove, sectionControllerCreate, sectionControllerDelete, sectionControllerUpdate, sectionControllerMove, questionControllerCreate, questionControllerDelete, questionControllerGetById, questionControllerUpdate, questionControllerFlagQuestion, questionControllerResolveFlag, quizControllerGetAllQuestionBanks, quizControllerEditQuestionBank, quizControllerAddQuestionBank, quizControllerRemoveQuestionBank, quizControllerGetUserMetrices, quizControllerGetQuizAttempt, quizControllerGetQuizSubmission, quizControllerGetAllSubmissions, quizControllerGetQuizDetails, quizControllerGetQuizAnalytics, quizControllerGetQuizPerformance, quizControllerGetQuizResults, quizControllerUpdateQuizSubmissionScore, quizControllerRegradeSubmission, quizControllerAddFeedbackToQuestion, quizControllerResetAvailableAttempts, questionBankControllerCreate, questionBankControllerGetById, questionBankControllerAddQuestion, questionBankControllerRemoveQuestion, questionBankControllerReplaceQuestion, attemptControllerAttempt, attemptControllerSave, attemptControllerSubmit, attemptControllerGetAttempt, genAiVideoControllerGenerateTranscript, genAiVideoControllerSegmentTranscript, genAiVideoControllerGenerateQuestions, genAiVideoControllerGenerateCourseItemsFromVideo, courseSettingsControllerCreate, courseSettingsControllerGet, courseSettingsControllerUpdateCourseSettings, userSettingsControllerCreate, userSettingsControllerGet, userSettingsControllerUpdateUserSettings } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, type DefaultError, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { InviteControllerGetInvitesForCourseVersionData, InviteControllerInviteUsersData, InviteControllerInviteUsersError, InviteControllerInviteUsersResponse, InviteControllerProcessInvitesData, InviteControllerResendInviteData, InviteControllerResendInviteResponse, InviteControllerCancelInviteData, InviteControllerCancelInviteResponse, EnrollmentControllerGetEnrollmentData, EnrollmentControllerEnrollUserData, EnrollmentControllerEnrollUserError, EnrollmentControllerEnrollUserResponse, EnrollmentControllerUnenrollUserData, EnrollmentControllerUnenrollUserError, EnrollmentControllerUnenrollUserResponse, EnrollmentControllerGetUserEnrollmentsData, EnrollmentControllerGetUserEnrollmentsError, EnrollmentControllerGetUserEnrollmentsResponse, EnrollmentControllerGetCourseVersionEnrollmentsData, EnrollmentControllerGetCourseVersionEnrollmentsError, EnrollmentControllerGetCourseVersionEnrollmentsResponse, ProgressControllerGetUserProgressData, ProgressControllerGetUserProgressPercentageData, ProgressControllerStartItemData, ProgressControllerStartItemError, ProgressControllerStartItemResponse, ProgressControllerStopItemData, ProgressControllerStopItemError, ProgressControllerUpdateProgressData, ProgressControllerUpdateProgressError, ProgressControllerResetProgressData, ProgressControllerResetProgressError, ProgressControllerGetWatchTimeData, UserControllerGetUserByIdData, UserControllerEditUserData, UserControllerEditUserError, UserControllerMakeAdminData, UserControllerMakeAdminError, AuthControllerSignupData, AuthControllerGoogleSignupData, AuthControllerChangePasswordData, AuthControllerLoginData, CourseControllerCreateData, CourseControllerCreateError, CourseControllerCreateResponse, CourseControllerDeleteData, CourseControllerDeleteError, CourseControllerReadData, CourseControllerUpdateData, CourseControllerUpdateError, CourseControllerUpdateResponse, CourseVersionControllerCreateData, CourseVersionControllerCreateError, CourseVersionControllerCreateResponse, CourseVersionControllerReadData, CourseVersionControllerDeleteData, CourseVersionControllerDeleteError, CourseVersionControllerDeleteResponse, ItemControllerReadAllData, ItemControllerCreateData, ItemControllerCreateError, ItemControllerCreateResponse, ItemControllerUpdateData, ItemControllerUpdateError, ItemControllerUpdateResponse, ItemControllerDeleteData, ItemControllerDeleteError, ItemControllerDeleteResponse, ItemControllerMoveData, ItemControllerMoveError, ItemControllerMoveResponse, ItemControllerGetItemData, ModuleControllerCreateData, ModuleControllerCreateError, ModuleControllerCreateResponse, ModuleControllerDeleteData, ModuleControllerDeleteError, ModuleControllerDeleteResponse, ModuleControllerUpdateData, ModuleControllerUpdateError, ModuleControllerUpdateResponse, ModuleControllerMoveData, ModuleControllerMoveError, ModuleControllerMoveResponse, SectionControllerCreateData, SectionControllerCreateError, SectionControllerCreateResponse, SectionControllerDeleteData, SectionControllerDeleteError, SectionControllerDeleteResponse, SectionControllerUpdateData, SectionControllerUpdateError, SectionControllerUpdateResponse, SectionControllerMoveData, SectionControllerMoveError, SectionControllerMoveResponse, QuestionControllerCreateData, QuestionControllerCreateError, QuestionControllerCreateResponse, QuestionControllerDeleteData, QuestionControllerDeleteError, QuestionControllerGetByIdData, QuestionControllerUpdateData, QuestionControllerUpdateResponse, QuestionControllerFlagQuestionData, QuestionControllerFlagQuestionError, QuestionControllerResolveFlagData, QuestionControllerResolveFlagError, QuizControllerGetAllQuestionBanksData, QuizControllerEditQuestionBankData, QuizControllerEditQuestionBankError, QuizControllerAddQuestionBankData, QuizControllerAddQuestionBankError, QuizControllerRemoveQuestionBankData, QuizControllerRemoveQuestionBankError, QuizControllerGetUserMetricesData, QuizControllerGetQuizAttemptData, QuizControllerGetQuizSubmissionData, QuizControllerGetAllSubmissionsData, QuizControllerGetQuizDetailsData, QuizControllerGetQuizAnalyticsData, QuizControllerGetQuizPerformanceData, QuizControllerGetQuizResultsData, QuizControllerUpdateQuizSubmissionScoreData, QuizControllerUpdateQuizSubmissionScoreError, QuizControllerRegradeSubmissionData, QuizControllerRegradeSubmissionError, QuizControllerAddFeedbackToQuestionData, QuizControllerAddFeedbackToQuestionError, QuizControllerResetAvailableAttemptsData, QuizControllerResetAvailableAttemptsError, QuestionBankControllerCreateData, QuestionBankControllerCreateError, QuestionBankControllerCreateResponse, QuestionBankControllerGetByIdData, QuestionBankControllerAddQuestionData, QuestionBankControllerAddQuestionError, QuestionBankControllerAddQuestionResponse, QuestionBankControllerRemoveQuestionData, QuestionBankControllerRemoveQuestionError, QuestionBankControllerRemoveQuestionResponse, QuestionBankControllerReplaceQuestionData, QuestionBankControllerReplaceQuestionError, QuestionBankControllerReplaceQuestionResponse, AttemptControllerAttemptData, AttemptControllerAttemptError, AttemptControllerAttemptResponse, AttemptControllerSaveData, AttemptControllerSaveError, AttemptControllerSubmitData, AttemptControllerSubmitError, AttemptControllerSubmitResponse, AttemptControllerGetAttemptData, GenAiVideoControllerGenerateTranscriptData, GenAiVideoControllerSegmentTranscriptData, GenAiVideoControllerGenerateQuestionsData, GenAiVideoControllerGenerateCourseItemsFromVideoData, CourseSettingsControllerCreateData, CourseSettingsControllerGetData, CourseSettingsControllerUpdateCourseSettingsData, UserSettingsControllerCreateData, UserSettingsControllerGetData, UserSettingsControllerUpdateUserSettingsData } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const inviteControllerGetInvitesForCourseVersionQueryKey = (options: Options<InviteControllerGetInvitesForCourseVersionData>) => createQueryKey('inviteControllerGetInvitesForCourseVersion', options);

/**
 * Get Invites for Course Version
 * Retrieve all invites for a specific course version.
 */
export const inviteControllerGetInvitesForCourseVersionOptions = (options: Options<InviteControllerGetInvitesForCourseVersionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await inviteControllerGetInvitesForCourseVersion({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: inviteControllerGetInvitesForCourseVersionQueryKey(options)
    });
};

export const inviteControllerInviteUsersQueryKey = (options: Options<InviteControllerInviteUsersData>) => createQueryKey('inviteControllerInviteUsers', options);

/**
 * Invite users to a course
 * Invites users to a specific version of a course.
 */
export const inviteControllerInviteUsersOptions = (options: Options<InviteControllerInviteUsersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await inviteControllerInviteUsers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: inviteControllerInviteUsersQueryKey(options)
    });
};

/**
 * Invite users to a course
 * Invites users to a specific version of a course.
 */
export const inviteControllerInviteUsersMutation = (options?: Partial<Options<InviteControllerInviteUsersData>>): UseMutationOptions<InviteControllerInviteUsersResponse, InviteControllerInviteUsersError, Options<InviteControllerInviteUsersData>> => {
    const mutationOptions: UseMutationOptions<InviteControllerInviteUsersResponse, InviteControllerInviteUsersError, Options<InviteControllerInviteUsersData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await inviteControllerInviteUsers({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const inviteControllerProcessInvitesQueryKey = (options: Options<InviteControllerProcessInvitesData>) => createQueryKey('inviteControllerProcessInvites', options);

/**
 * Process Invite
 * Process an invite given an inviteId and send a response before redirecting the user.
 */
export const inviteControllerProcessInvitesOptions = (options: Options<InviteControllerProcessInvitesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await inviteControllerProcessInvites({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: inviteControllerProcessInvitesQueryKey(options)
    });
};

export const inviteControllerResendInviteQueryKey = (options: Options<InviteControllerResendInviteData>) => createQueryKey('inviteControllerResendInvite', options);

/**
 * Resend Invite
 * Resend an invite email to the user.
 */
export const inviteControllerResendInviteOptions = (options: Options<InviteControllerResendInviteData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await inviteControllerResendInvite({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: inviteControllerResendInviteQueryKey(options)
    });
};

/**
 * Resend Invite
 * Resend an invite email to the user.
 */
export const inviteControllerResendInviteMutation = (options?: Partial<Options<InviteControllerResendInviteData>>): UseMutationOptions<InviteControllerResendInviteResponse, DefaultError, Options<InviteControllerResendInviteData>> => {
    const mutationOptions: UseMutationOptions<InviteControllerResendInviteResponse, DefaultError, Options<InviteControllerResendInviteData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await inviteControllerResendInvite({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const inviteControllerCancelInviteQueryKey = (options: Options<InviteControllerCancelInviteData>) => createQueryKey('inviteControllerCancelInvite', options);

/**
 * Cancel Invite
 * Cancel an existing invite.
 */
export const inviteControllerCancelInviteOptions = (options: Options<InviteControllerCancelInviteData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await inviteControllerCancelInvite({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: inviteControllerCancelInviteQueryKey(options)
    });
};

/**
 * Cancel Invite
 * Cancel an existing invite.
 */
export const inviteControllerCancelInviteMutation = (options?: Partial<Options<InviteControllerCancelInviteData>>): UseMutationOptions<InviteControllerCancelInviteResponse, DefaultError, Options<InviteControllerCancelInviteData>> => {
    const mutationOptions: UseMutationOptions<InviteControllerCancelInviteResponse, DefaultError, Options<InviteControllerCancelInviteData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await inviteControllerCancelInvite({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const enrollmentControllerGetEnrollmentQueryKey = (options: Options<EnrollmentControllerGetEnrollmentData>) => createQueryKey('enrollmentControllerGetEnrollment', options);

/**
 * Get enrollment details for a user in a course version
 * Retrieves enrollment details, including role and status, for a user in a specific course version.
 */
export const enrollmentControllerGetEnrollmentOptions = (options: Options<EnrollmentControllerGetEnrollmentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await enrollmentControllerGetEnrollment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enrollmentControllerGetEnrollmentQueryKey(options)
    });
};

export const enrollmentControllerEnrollUserQueryKey = (options: Options<EnrollmentControllerEnrollUserData>) => createQueryKey('enrollmentControllerEnrollUser', options);

/**
 * Enroll a user in a course version
 * Enrolls a user in a specific course version with a given role.
 */
export const enrollmentControllerEnrollUserOptions = (options: Options<EnrollmentControllerEnrollUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await enrollmentControllerEnrollUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enrollmentControllerEnrollUserQueryKey(options)
    });
};

/**
 * Enroll a user in a course version
 * Enrolls a user in a specific course version with a given role.
 */
export const enrollmentControllerEnrollUserMutation = (options?: Partial<Options<EnrollmentControllerEnrollUserData>>): UseMutationOptions<EnrollmentControllerEnrollUserResponse, EnrollmentControllerEnrollUserError, Options<EnrollmentControllerEnrollUserData>> => {
    const mutationOptions: UseMutationOptions<EnrollmentControllerEnrollUserResponse, EnrollmentControllerEnrollUserError, Options<EnrollmentControllerEnrollUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await enrollmentControllerEnrollUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const enrollmentControllerUnenrollUserQueryKey = (options: Options<EnrollmentControllerUnenrollUserData>) => createQueryKey('enrollmentControllerUnenrollUser', options);

/**
 * Unenroll a user from a course version
 * Removes a user's enrollment and progress from a specific course version.
 */
export const enrollmentControllerUnenrollUserOptions = (options: Options<EnrollmentControllerUnenrollUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await enrollmentControllerUnenrollUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enrollmentControllerUnenrollUserQueryKey(options)
    });
};

/**
 * Unenroll a user from a course version
 * Removes a user's enrollment and progress from a specific course version.
 */
export const enrollmentControllerUnenrollUserMutation = (options?: Partial<Options<EnrollmentControllerUnenrollUserData>>): UseMutationOptions<EnrollmentControllerUnenrollUserResponse, EnrollmentControllerUnenrollUserError, Options<EnrollmentControllerUnenrollUserData>> => {
    const mutationOptions: UseMutationOptions<EnrollmentControllerUnenrollUserResponse, EnrollmentControllerUnenrollUserError, Options<EnrollmentControllerUnenrollUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await enrollmentControllerUnenrollUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const enrollmentControllerGetUserEnrollmentsQueryKey = (options?: Options<EnrollmentControllerGetUserEnrollmentsData>) => createQueryKey('enrollmentControllerGetUserEnrollments', options);

/**
 * Get all enrollments for a user
 * Retrieves a paginated list of all course enrollments for a user.
 */
export const enrollmentControllerGetUserEnrollmentsOptions = (options?: Options<EnrollmentControllerGetUserEnrollmentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await enrollmentControllerGetUserEnrollments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enrollmentControllerGetUserEnrollmentsQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = {
        ...queryKey[0]
    };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const enrollmentControllerGetUserEnrollmentsInfiniteQueryKey = (options?: Options<EnrollmentControllerGetUserEnrollmentsData>): QueryKey<Options<EnrollmentControllerGetUserEnrollmentsData>> => createQueryKey('enrollmentControllerGetUserEnrollments', options, true);

/**
 * Get all enrollments for a user
 * Retrieves a paginated list of all course enrollments for a user.
 */
export const enrollmentControllerGetUserEnrollmentsInfiniteOptions = (options?: Options<EnrollmentControllerGetUserEnrollmentsData>) => {
    return infiniteQueryOptions<EnrollmentControllerGetUserEnrollmentsResponse, EnrollmentControllerGetUserEnrollmentsError, InfiniteData<EnrollmentControllerGetUserEnrollmentsResponse>, QueryKey<Options<EnrollmentControllerGetUserEnrollmentsData>>, unknown | Pick<QueryKey<Options<EnrollmentControllerGetUserEnrollmentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<EnrollmentControllerGetUserEnrollmentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await enrollmentControllerGetUserEnrollments({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enrollmentControllerGetUserEnrollmentsInfiniteQueryKey(options)
    });
};

export const enrollmentControllerGetCourseVersionEnrollmentsQueryKey = (options: Options<EnrollmentControllerGetCourseVersionEnrollmentsData>) => createQueryKey('enrollmentControllerGetCourseVersionEnrollments', options);

/**
 * Get all enrollments for a course version
 * Retrieves a paginated list of all users enrolled in a specific course version.
 */
export const enrollmentControllerGetCourseVersionEnrollmentsOptions = (options: Options<EnrollmentControllerGetCourseVersionEnrollmentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await enrollmentControllerGetCourseVersionEnrollments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enrollmentControllerGetCourseVersionEnrollmentsQueryKey(options)
    });
};

export const enrollmentControllerGetCourseVersionEnrollmentsInfiniteQueryKey = (options: Options<EnrollmentControllerGetCourseVersionEnrollmentsData>): QueryKey<Options<EnrollmentControllerGetCourseVersionEnrollmentsData>> => createQueryKey('enrollmentControllerGetCourseVersionEnrollments', options, true);

/**
 * Get all enrollments for a course version
 * Retrieves a paginated list of all users enrolled in a specific course version.
 */
export const enrollmentControllerGetCourseVersionEnrollmentsInfiniteOptions = (options: Options<EnrollmentControllerGetCourseVersionEnrollmentsData>) => {
    return infiniteQueryOptions<EnrollmentControllerGetCourseVersionEnrollmentsResponse, EnrollmentControllerGetCourseVersionEnrollmentsError, InfiniteData<EnrollmentControllerGetCourseVersionEnrollmentsResponse>, QueryKey<Options<EnrollmentControllerGetCourseVersionEnrollmentsData>>, unknown | Pick<QueryKey<Options<EnrollmentControllerGetCourseVersionEnrollmentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<EnrollmentControllerGetCourseVersionEnrollmentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await enrollmentControllerGetCourseVersionEnrollments({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enrollmentControllerGetCourseVersionEnrollmentsInfiniteQueryKey(options)
    });
};

export const progressControllerGetUserProgressQueryKey = (options: Options<ProgressControllerGetUserProgressData>) => createQueryKey('progressControllerGetUserProgress', options);

/**
 * Get user progress in a course version
 * Retrieves the progress of a user in a specific course version.
 */
export const progressControllerGetUserProgressOptions = (options: Options<ProgressControllerGetUserProgressData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await progressControllerGetUserProgress({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: progressControllerGetUserProgressQueryKey(options)
    });
};

export const progressControllerGetUserProgressPercentageQueryKey = (options: Options<ProgressControllerGetUserProgressPercentageData>) => createQueryKey('progressControllerGetUserProgressPercentage', options);

/**
 * Get %age progress in a course version
 * Retrieves the progress of a user in a specific course version.
 */
export const progressControllerGetUserProgressPercentageOptions = (options: Options<ProgressControllerGetUserProgressPercentageData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await progressControllerGetUserProgressPercentage({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: progressControllerGetUserProgressPercentageQueryKey(options)
    });
};

export const progressControllerStartItemQueryKey = (options: Options<ProgressControllerStartItemData>) => createQueryKey('progressControllerStartItem', options);

/**
 * Start an item for user progress
 * Marks the start of an item for a user in a course version.
 */
export const progressControllerStartItemOptions = (options: Options<ProgressControllerStartItemData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await progressControllerStartItem({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: progressControllerStartItemQueryKey(options)
    });
};

/**
 * Start an item for user progress
 * Marks the start of an item for a user in a course version.
 */
export const progressControllerStartItemMutation = (options?: Partial<Options<ProgressControllerStartItemData>>): UseMutationOptions<ProgressControllerStartItemResponse, ProgressControllerStartItemError, Options<ProgressControllerStartItemData>> => {
    const mutationOptions: UseMutationOptions<ProgressControllerStartItemResponse, ProgressControllerStartItemError, Options<ProgressControllerStartItemData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await progressControllerStartItem({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const progressControllerStopItemQueryKey = (options: Options<ProgressControllerStopItemData>) => createQueryKey('progressControllerStopItem', options);

/**
 * Stop an item for user progress
 * Marks the stop of an item for a user in a course version.
 */
export const progressControllerStopItemOptions = (options: Options<ProgressControllerStopItemData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await progressControllerStopItem({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: progressControllerStopItemQueryKey(options)
    });
};

/**
 * Stop an item for user progress
 * Marks the stop of an item for a user in a course version.
 */
export const progressControllerStopItemMutation = (options?: Partial<Options<ProgressControllerStopItemData>>): UseMutationOptions<unknown, ProgressControllerStopItemError, Options<ProgressControllerStopItemData>> => {
    const mutationOptions: UseMutationOptions<unknown, ProgressControllerStopItemError, Options<ProgressControllerStopItemData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await progressControllerStopItem({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update user progress
 * Updates the progress of a user for a specific item in a course version.
 */
export const progressControllerUpdateProgressMutation = (options?: Partial<Options<ProgressControllerUpdateProgressData>>): UseMutationOptions<unknown, ProgressControllerUpdateProgressError, Options<ProgressControllerUpdateProgressData>> => {
    const mutationOptions: UseMutationOptions<unknown, ProgressControllerUpdateProgressError, Options<ProgressControllerUpdateProgressData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await progressControllerUpdateProgress({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Reset user progress
 * Resets the user's progress in a course version.
 * If only moduleId is provided, resets to the beginning of the module.
 * If moduleId and sectionId are provided, resets to the beginning of the section.
 * If moduleId, sectionId, and itemId are provided, resets to the beginning of the item.
 * If none are provided, resets to the beginning of the course.
 */
export const progressControllerResetProgressMutation = (options?: Partial<Options<ProgressControllerResetProgressData>>): UseMutationOptions<unknown, ProgressControllerResetProgressError, Options<ProgressControllerResetProgressData>> => {
    const mutationOptions: UseMutationOptions<unknown, ProgressControllerResetProgressError, Options<ProgressControllerResetProgressData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await progressControllerResetProgress({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const progressControllerGetWatchTimeQueryKey = (options: Options<ProgressControllerGetWatchTimeData>) => createQueryKey('progressControllerGetWatchTime', options);

/**
 * Get User Watch Time
 * Gets the User Watch Time for the given Item Id
 */
export const progressControllerGetWatchTimeOptions = (options: Options<ProgressControllerGetWatchTimeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await progressControllerGetWatchTime({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: progressControllerGetWatchTimeQueryKey(options)
    });
};

export const userControllerGetUserByIdQueryKey = (options: Options<UserControllerGetUserByIdData>) => createQueryKey('userControllerGetUserById', options);

/**
 * Get user information by user ID
 * Retrieves user information based on the provided user ID.
 */
export const userControllerGetUserByIdOptions = (options: Options<UserControllerGetUserByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await userControllerGetUserById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: userControllerGetUserByIdQueryKey(options)
    });
};

/**
 * Edit user information
 * Edit user information like first and last name.
 */
export const userControllerEditUserMutation = (options?: Partial<Options<UserControllerEditUserData>>): UseMutationOptions<unknown, UserControllerEditUserError, Options<UserControllerEditUserData>> => {
    const mutationOptions: UseMutationOptions<unknown, UserControllerEditUserError, Options<UserControllerEditUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await userControllerEditUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const userControllerMakeAdminQueryKey = (options: Options<UserControllerMakeAdminData>) => createQueryKey('userControllerMakeAdmin', options);

/**
 * Make a user an admin
 * Promotes a user to admin status based on the provided user ID.
 */
export const userControllerMakeAdminOptions = (options: Options<UserControllerMakeAdminData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await userControllerMakeAdmin({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: userControllerMakeAdminQueryKey(options)
    });
};

/**
 * Make a user an admin
 * Promotes a user to admin status based on the provided user ID.
 */
export const userControllerMakeAdminMutation = (options?: Partial<Options<UserControllerMakeAdminData>>): UseMutationOptions<unknown, UserControllerMakeAdminError, Options<UserControllerMakeAdminData>> => {
    const mutationOptions: UseMutationOptions<unknown, UserControllerMakeAdminError, Options<UserControllerMakeAdminData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await userControllerMakeAdmin({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const authControllerSignupQueryKey = (options?: Options<AuthControllerSignupData>) => createQueryKey('authControllerSignup', options);

/**
 * Register a new user account
 * Registers a new user using Firebase Authentication and stores additional user details in the application database. This is typically the first step for any new user to access the system.
 */
export const authControllerSignupOptions = (options?: Options<AuthControllerSignupData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authControllerSignup({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authControllerSignupQueryKey(options)
    });
};

/**
 * Register a new user account
 * Registers a new user using Firebase Authentication and stores additional user details in the application database. This is typically the first step for any new user to access the system.
 */
export const authControllerSignupMutation = (options?: Partial<Options<AuthControllerSignupData>>): UseMutationOptions<unknown, DefaultError, Options<AuthControllerSignupData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<AuthControllerSignupData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await authControllerSignup({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const authControllerGoogleSignupQueryKey = (options?: Options<AuthControllerGoogleSignupData>) => createQueryKey('authControllerGoogleSignup', options);

/**
 * Register a new user account
 * Registers a new user using Firebase Authentication and stores additional user details in the application database. This is typically the first step for any new user to access the system.
 */
export const authControllerGoogleSignupOptions = (options?: Options<AuthControllerGoogleSignupData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authControllerGoogleSignup({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authControllerGoogleSignupQueryKey(options)
    });
};

/**
 * Register a new user account
 * Registers a new user using Firebase Authentication and stores additional user details in the application database. This is typically the first step for any new user to access the system.
 */
export const authControllerGoogleSignupMutation = (options?: Partial<Options<AuthControllerGoogleSignupData>>): UseMutationOptions<unknown, DefaultError, Options<AuthControllerGoogleSignupData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<AuthControllerGoogleSignupData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await authControllerGoogleSignup({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Change user password
 * Allows an authenticated user to update their password. This action is performed via Firebase Authentication and requires the current credentials to be valid.
 */
export const authControllerChangePasswordMutation = (options?: Partial<Options<AuthControllerChangePasswordData>>): UseMutationOptions<unknown, DefaultError, Options<AuthControllerChangePasswordData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<AuthControllerChangePasswordData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await authControllerChangePassword({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const authControllerLoginQueryKey = (options?: Options<AuthControllerLoginData>) => createQueryKey('authControllerLogin', options);

/**
 * Login
 */
export const authControllerLoginOptions = (options?: Options<AuthControllerLoginData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await authControllerLogin({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: authControllerLoginQueryKey(options)
    });
};

/**
 * Login
 */
export const authControllerLoginMutation = (options?: Partial<Options<AuthControllerLoginData>>): UseMutationOptions<unknown, DefaultError, Options<AuthControllerLoginData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<AuthControllerLoginData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await authControllerLogin({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const courseControllerCreateQueryKey = (options?: Options<CourseControllerCreateData>) => createQueryKey('courseControllerCreate', options);

/**
 * Create a new course
 * Creates a new course in the system.<br/>.
 */
export const courseControllerCreateOptions = (options?: Options<CourseControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseControllerCreateQueryKey(options)
    });
};

/**
 * Create a new course
 * Creates a new course in the system.<br/>.
 */
export const courseControllerCreateMutation = (options?: Partial<Options<CourseControllerCreateData>>): UseMutationOptions<CourseControllerCreateResponse, CourseControllerCreateError, Options<CourseControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<CourseControllerCreateResponse, CourseControllerCreateError, Options<CourseControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a course
 * Deletes a course by ID.
 */
export const courseControllerDeleteMutation = (options?: Partial<Options<CourseControllerDeleteData>>): UseMutationOptions<unknown, CourseControllerDeleteError, Options<CourseControllerDeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, CourseControllerDeleteError, Options<CourseControllerDeleteData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseControllerDelete({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const courseControllerReadQueryKey = (options: Options<CourseControllerReadData>) => createQueryKey('courseControllerRead', options);

/**
 * Get course details
 * Retrieves course information by ID.<br/>
 * Accessible to:
 * - Users who are part of the course (students, teaching assistants, instructors, or managers)
 *
 */
export const courseControllerReadOptions = (options: Options<CourseControllerReadData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseControllerRead({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseControllerReadQueryKey(options)
    });
};

/**
 * Update a course
 * Updates course metadata such as title or description.<br/>
 * Accessible to:
 * - Instructor or manager for the course.
 */
export const courseControllerUpdateMutation = (options?: Partial<Options<CourseControllerUpdateData>>): UseMutationOptions<CourseControllerUpdateResponse, CourseControllerUpdateError, Options<CourseControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<CourseControllerUpdateResponse, CourseControllerUpdateError, Options<CourseControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const courseVersionControllerCreateQueryKey = (options: Options<CourseVersionControllerCreateData>) => createQueryKey('courseVersionControllerCreate', options);

/**
 * Create a course version
 * Creates a new version of a given course.<br/>
 * Accessible to:
 * - Instructor or manager of the course.
 */
export const courseVersionControllerCreateOptions = (options: Options<CourseVersionControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseVersionControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseVersionControllerCreateQueryKey(options)
    });
};

/**
 * Create a course version
 * Creates a new version of a given course.<br/>
 * Accessible to:
 * - Instructor or manager of the course.
 */
export const courseVersionControllerCreateMutation = (options?: Partial<Options<CourseVersionControllerCreateData>>): UseMutationOptions<CourseVersionControllerCreateResponse, CourseVersionControllerCreateError, Options<CourseVersionControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<CourseVersionControllerCreateResponse, CourseVersionControllerCreateError, Options<CourseVersionControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseVersionControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const courseVersionControllerReadQueryKey = (options: Options<CourseVersionControllerReadData>) => createQueryKey('courseVersionControllerRead', options);

/**
 * Get course version details
 * Retrieves information about a specific version of a course.<br/>
 * Accessible to:
 * - Users who are part of the course version (students, teaching assistants, instructors, or managers).
 */
export const courseVersionControllerReadOptions = (options: Options<CourseVersionControllerReadData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseVersionControllerRead({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseVersionControllerReadQueryKey(options)
    });
};

/**
 * Delete a course version
 * Deletes a specific version of a course.<br/>
 * Accessible to:
 * - Manager of the course.
 */
export const courseVersionControllerDeleteMutation = (options?: Partial<Options<CourseVersionControllerDeleteData>>): UseMutationOptions<CourseVersionControllerDeleteResponse, CourseVersionControllerDeleteError, Options<CourseVersionControllerDeleteData>> => {
    const mutationOptions: UseMutationOptions<CourseVersionControllerDeleteResponse, CourseVersionControllerDeleteError, Options<CourseVersionControllerDeleteData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseVersionControllerDelete({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const itemControllerReadAllQueryKey = (options: Options<ItemControllerReadAllData>) => createQueryKey('itemControllerReadAll', options);

/**
 * Get all item references in a section
 * Retrieves a list of item references from a specific section. Each reference includes only the item's `_id`, `type`, and `order`, without full item details.<br/>
 * Accessible to:
 * - All users who are part of the course.
 */
export const itemControllerReadAllOptions = (options: Options<ItemControllerReadAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await itemControllerReadAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: itemControllerReadAllQueryKey(options)
    });
};

export const itemControllerCreateQueryKey = (options: Options<ItemControllerCreateData>) => createQueryKey('itemControllerCreate', options);

/**
 * Create an item
 * Creates a new item within a section.
 * Accessible to:
 * - Instructors, managers or teaching assistants of the course.
 */
export const itemControllerCreateOptions = (options: Options<ItemControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await itemControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: itemControllerCreateQueryKey(options)
    });
};

/**
 * Create an item
 * Creates a new item within a section.
 * Accessible to:
 * - Instructors, managers or teaching assistants of the course.
 */
export const itemControllerCreateMutation = (options?: Partial<Options<ItemControllerCreateData>>): UseMutationOptions<ItemControllerCreateResponse, ItemControllerCreateError, Options<ItemControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<ItemControllerCreateResponse, ItemControllerCreateError, Options<ItemControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await itemControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update an item
 * Updates the configuration or content of a specific item within a section.<br/>
 * Accessible to:
 * - Instructors, managers, and teaching assistants of the course.
 */
export const itemControllerUpdateMutation = (options?: Partial<Options<ItemControllerUpdateData>>): UseMutationOptions<ItemControllerUpdateResponse, ItemControllerUpdateError, Options<ItemControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<ItemControllerUpdateResponse, ItemControllerUpdateError, Options<ItemControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await itemControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete an item
 * Deletes a specific item from a section.<br/>
 * Accessible to:
 * - Instructors or managers of the course.
 */
export const itemControllerDeleteMutation = (options?: Partial<Options<ItemControllerDeleteData>>): UseMutationOptions<ItemControllerDeleteResponse, ItemControllerDeleteError, Options<ItemControllerDeleteData>> => {
    const mutationOptions: UseMutationOptions<ItemControllerDeleteResponse, ItemControllerDeleteError, Options<ItemControllerDeleteData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await itemControllerDelete({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Reorder an item
 * Changes the position of an item within a section of a course version.<br/>
 * Accessible to:
 * - Instructors, managers, and teaching assistants of the course.
 */
export const itemControllerMoveMutation = (options?: Partial<Options<ItemControllerMoveData>>): UseMutationOptions<ItemControllerMoveResponse, ItemControllerMoveError, Options<ItemControllerMoveData>> => {
    const mutationOptions: UseMutationOptions<ItemControllerMoveResponse, ItemControllerMoveError, Options<ItemControllerMoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await itemControllerMove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const itemControllerGetItemQueryKey = (options: Options<ItemControllerGetItemData>) => createQueryKey('itemControllerGetItem', options);

/**
 * Get an item by ID
 * Retrieves a specific item from a course version.<br/>
 * Access control logic:
 * - For students: The item is returned only if it matches the student's current item ID in their course progress.
 * - For instructors, managers, and teaching assistants: The item is accessible without this restriction.
 */
export const itemControllerGetItemOptions = (options: Options<ItemControllerGetItemData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await itemControllerGetItem({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: itemControllerGetItemQueryKey(options)
    });
};

export const moduleControllerCreateQueryKey = (options: Options<ModuleControllerCreateData>) => createQueryKey('moduleControllerCreate', options);

/**
 * Create a module
 * Creates a new module within a specific course version.<br/>
 * Accessible to:
 * - Instructors or managers of the course.
 */
export const moduleControllerCreateOptions = (options: Options<ModuleControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await moduleControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: moduleControllerCreateQueryKey(options)
    });
};

/**
 * Create a module
 * Creates a new module within a specific course version.<br/>
 * Accessible to:
 * - Instructors or managers of the course.
 */
export const moduleControllerCreateMutation = (options?: Partial<Options<ModuleControllerCreateData>>): UseMutationOptions<ModuleControllerCreateResponse, ModuleControllerCreateError, Options<ModuleControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<ModuleControllerCreateResponse, ModuleControllerCreateError, Options<ModuleControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await moduleControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a module
 * Deletes a module from a specific course version.<br/>
 * Accessible to:
 * - Instructors or managers of the course.
 */
export const moduleControllerDeleteMutation = (options?: Partial<Options<ModuleControllerDeleteData>>): UseMutationOptions<ModuleControllerDeleteResponse, ModuleControllerDeleteError, Options<ModuleControllerDeleteData>> => {
    const mutationOptions: UseMutationOptions<ModuleControllerDeleteResponse, ModuleControllerDeleteError, Options<ModuleControllerDeleteData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await moduleControllerDelete({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update a module
 * Updates the content or metadata of a module in a given course version.<br/>
 * Accessible to:
 * - Instructors or managers of the course.
 */
export const moduleControllerUpdateMutation = (options?: Partial<Options<ModuleControllerUpdateData>>): UseMutationOptions<ModuleControllerUpdateResponse, ModuleControllerUpdateError, Options<ModuleControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<ModuleControllerUpdateResponse, ModuleControllerUpdateError, Options<ModuleControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await moduleControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Reorder a module
 * Changes the position of a module within the sequence of modules in the course version.<br/>
 * Accessible to:
 * - Instructors or managers of the course.
 */
export const moduleControllerMoveMutation = (options?: Partial<Options<ModuleControllerMoveData>>): UseMutationOptions<ModuleControllerMoveResponse, ModuleControllerMoveError, Options<ModuleControllerMoveData>> => {
    const mutationOptions: UseMutationOptions<ModuleControllerMoveResponse, ModuleControllerMoveError, Options<ModuleControllerMoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await moduleControllerMove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const sectionControllerCreateQueryKey = (options: Options<SectionControllerCreateData>) => createQueryKey('sectionControllerCreate', options);

/**
 * Create a section
 * Creates a new section within a module of a specific course version.<br/>
 * Accessible to:
 * - Instructors or managers of the course.
 */
export const sectionControllerCreateOptions = (options: Options<SectionControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await sectionControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: sectionControllerCreateQueryKey(options)
    });
};

/**
 * Create a section
 * Creates a new section within a module of a specific course version.<br/>
 * Accessible to:
 * - Instructors or managers of the course.
 */
export const sectionControllerCreateMutation = (options?: Partial<Options<SectionControllerCreateData>>): UseMutationOptions<SectionControllerCreateResponse, SectionControllerCreateError, Options<SectionControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<SectionControllerCreateResponse, SectionControllerCreateError, Options<SectionControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await sectionControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a section
 * Deletes a section from a module in a specific course version.<br/>
 * Accessible to:
 * - Instructors or managers of the course.
 */
export const sectionControllerDeleteMutation = (options?: Partial<Options<SectionControllerDeleteData>>): UseMutationOptions<SectionControllerDeleteResponse, SectionControllerDeleteError, Options<SectionControllerDeleteData>> => {
    const mutationOptions: UseMutationOptions<SectionControllerDeleteResponse, SectionControllerDeleteError, Options<SectionControllerDeleteData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await sectionControllerDelete({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update a section
 * Updates the title, description, or configuration of a section within a module of a specific course version.<br/>
 * Accessible to:
 * - Instructors or managers of the course.
 */
export const sectionControllerUpdateMutation = (options?: Partial<Options<SectionControllerUpdateData>>): UseMutationOptions<SectionControllerUpdateResponse, SectionControllerUpdateError, Options<SectionControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<SectionControllerUpdateResponse, SectionControllerUpdateError, Options<SectionControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await sectionControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Reorder a section
 * Changes the position of a section within its module in a specific course version.<br/>
 * Accessible to:
 * - Instructors or managers of the course.
 */
export const sectionControllerMoveMutation = (options?: Partial<Options<SectionControllerMoveData>>): UseMutationOptions<SectionControllerMoveResponse, SectionControllerMoveError, Options<SectionControllerMoveData>> => {
    const mutationOptions: UseMutationOptions<SectionControllerMoveResponse, SectionControllerMoveError, Options<SectionControllerMoveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await sectionControllerMove({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const questionControllerCreateQueryKey = (options?: Options<QuestionControllerCreateData>) => createQueryKey('questionControllerCreate', options);

/**
 * Create a new question
 * Creates a new quiz question and returns its ID.
 */
export const questionControllerCreateOptions = (options?: Options<QuestionControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await questionControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: questionControllerCreateQueryKey(options)
    });
};

/**
 * Create a new question
 * Creates a new quiz question and returns its ID.
 */
export const questionControllerCreateMutation = (options?: Partial<Options<QuestionControllerCreateData>>): UseMutationOptions<QuestionControllerCreateResponse, QuestionControllerCreateError, Options<QuestionControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<QuestionControllerCreateResponse, QuestionControllerCreateError, Options<QuestionControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await questionControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete a question
 * Deletes a quiz question by its ID.
 */
export const questionControllerDeleteMutation = (options?: Partial<Options<QuestionControllerDeleteData>>): UseMutationOptions<unknown, QuestionControllerDeleteError, Options<QuestionControllerDeleteData>> => {
    const mutationOptions: UseMutationOptions<unknown, QuestionControllerDeleteError, Options<QuestionControllerDeleteData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await questionControllerDelete({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const questionControllerGetByIdQueryKey = (options: Options<QuestionControllerGetByIdData>) => createQueryKey('questionControllerGetById', options);

/**
 * Get question by ID
 * Retrieves a quiz question by its ID.
 */
export const questionControllerGetByIdOptions = (options: Options<QuestionControllerGetByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await questionControllerGetById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: questionControllerGetByIdQueryKey(options)
    });
};

/**
 * Update a question
 * Updates an existing quiz question.
 */
export const questionControllerUpdateMutation = (options?: Partial<Options<QuestionControllerUpdateData>>): UseMutationOptions<QuestionControllerUpdateResponse, DefaultError, Options<QuestionControllerUpdateData>> => {
    const mutationOptions: UseMutationOptions<QuestionControllerUpdateResponse, DefaultError, Options<QuestionControllerUpdateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await questionControllerUpdate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const questionControllerFlagQuestionQueryKey = (options: Options<QuestionControllerFlagQuestionData>) => createQueryKey('questionControllerFlagQuestion', options);

/**
 * Flag a question
 * Flags a quiz question for review with a reason.
 */
export const questionControllerFlagQuestionOptions = (options: Options<QuestionControllerFlagQuestionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await questionControllerFlagQuestion({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: questionControllerFlagQuestionQueryKey(options)
    });
};

/**
 * Flag a question
 * Flags a quiz question for review with a reason.
 */
export const questionControllerFlagQuestionMutation = (options?: Partial<Options<QuestionControllerFlagQuestionData>>): UseMutationOptions<unknown, QuestionControllerFlagQuestionError, Options<QuestionControllerFlagQuestionData>> => {
    const mutationOptions: UseMutationOptions<unknown, QuestionControllerFlagQuestionError, Options<QuestionControllerFlagQuestionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await questionControllerFlagQuestion({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const questionControllerResolveFlagQueryKey = (options: Options<QuestionControllerResolveFlagData>) => createQueryKey('questionControllerResolveFlag', options);

/**
 * Resolve a flagged question
 * Resolves a flagged question by marking it as resolved or rejected.
 */
export const questionControllerResolveFlagOptions = (options: Options<QuestionControllerResolveFlagData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await questionControllerResolveFlag({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: questionControllerResolveFlagQueryKey(options)
    });
};

/**
 * Resolve a flagged question
 * Resolves a flagged question by marking it as resolved or rejected.
 */
export const questionControllerResolveFlagMutation = (options?: Partial<Options<QuestionControllerResolveFlagData>>): UseMutationOptions<unknown, QuestionControllerResolveFlagError, Options<QuestionControllerResolveFlagData>> => {
    const mutationOptions: UseMutationOptions<unknown, QuestionControllerResolveFlagError, Options<QuestionControllerResolveFlagData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await questionControllerResolveFlag({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const quizControllerGetAllQuestionBanksQueryKey = (options: Options<QuizControllerGetAllQuestionBanksData>) => createQueryKey('quizControllerGetAllQuestionBanks', options);

/**
 * Get all question banks for a quiz
 * Retrieves all question banks associated with a quiz.
 */
export const quizControllerGetAllQuestionBanksOptions = (options: Options<QuizControllerGetAllQuestionBanksData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await quizControllerGetAllQuestionBanks({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: quizControllerGetAllQuestionBanksQueryKey(options)
    });
};

/**
 * Edit question bank configuration for a quiz
 * Updates the configuration of a question bank within a quiz.
 */
export const quizControllerEditQuestionBankMutation = (options?: Partial<Options<QuizControllerEditQuestionBankData>>): UseMutationOptions<unknown, QuizControllerEditQuestionBankError, Options<QuizControllerEditQuestionBankData>> => {
    const mutationOptions: UseMutationOptions<unknown, QuizControllerEditQuestionBankError, Options<QuizControllerEditQuestionBankData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await quizControllerEditQuestionBank({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const quizControllerAddQuestionBankQueryKey = (options: Options<QuizControllerAddQuestionBankData>) => createQueryKey('quizControllerAddQuestionBank', options);

/**
 * Add a question bank to a quiz
 * Associates a question bank with a quiz.
 */
export const quizControllerAddQuestionBankOptions = (options: Options<QuizControllerAddQuestionBankData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await quizControllerAddQuestionBank({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: quizControllerAddQuestionBankQueryKey(options)
    });
};

/**
 * Add a question bank to a quiz
 * Associates a question bank with a quiz.
 */
export const quizControllerAddQuestionBankMutation = (options?: Partial<Options<QuizControllerAddQuestionBankData>>): UseMutationOptions<unknown, QuizControllerAddQuestionBankError, Options<QuizControllerAddQuestionBankData>> => {
    const mutationOptions: UseMutationOptions<unknown, QuizControllerAddQuestionBankError, Options<QuizControllerAddQuestionBankData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await quizControllerAddQuestionBank({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove a question bank from a quiz
 * Removes the association of a question bank from a quiz.
 */
export const quizControllerRemoveQuestionBankMutation = (options?: Partial<Options<QuizControllerRemoveQuestionBankData>>): UseMutationOptions<unknown, QuizControllerRemoveQuestionBankError, Options<QuizControllerRemoveQuestionBankData>> => {
    const mutationOptions: UseMutationOptions<unknown, QuizControllerRemoveQuestionBankError, Options<QuizControllerRemoveQuestionBankData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await quizControllerRemoveQuestionBank({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const quizControllerGetUserMetricesQueryKey = (options: Options<QuizControllerGetUserMetricesData>) => createQueryKey('quizControllerGetUserMetrices', options);

/**
 * Get user metrics for a quiz
 * Retrieves quiz metrics for a specific user.
 */
export const quizControllerGetUserMetricesOptions = (options: Options<QuizControllerGetUserMetricesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await quizControllerGetUserMetrices({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: quizControllerGetUserMetricesQueryKey(options)
    });
};

export const quizControllerGetQuizAttemptQueryKey = (options: Options<QuizControllerGetQuizAttemptData>) => createQueryKey('quizControllerGetQuizAttempt', options);

/**
 * Get quiz attempt details
 * Retrieves details of a specific quiz attempt.
 */
export const quizControllerGetQuizAttemptOptions = (options: Options<QuizControllerGetQuizAttemptData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await quizControllerGetQuizAttempt({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: quizControllerGetQuizAttemptQueryKey(options)
    });
};

export const quizControllerGetQuizSubmissionQueryKey = (options: Options<QuizControllerGetQuizSubmissionData>) => createQueryKey('quizControllerGetQuizSubmission', options);

/**
 * Get quiz submission details
 * Retrieves details of a specific quiz submission.
 */
export const quizControllerGetQuizSubmissionOptions = (options: Options<QuizControllerGetQuizSubmissionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await quizControllerGetQuizSubmission({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: quizControllerGetQuizSubmissionQueryKey(options)
    });
};

export const quizControllerGetAllSubmissionsQueryKey = (options: Options<QuizControllerGetAllSubmissionsData>) => createQueryKey('quizControllerGetAllSubmissions', options);

/**
 * Get all submissions for a quiz
 * Retrieves all submissions for a quiz.
 */
export const quizControllerGetAllSubmissionsOptions = (options: Options<QuizControllerGetAllSubmissionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await quizControllerGetAllSubmissions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: quizControllerGetAllSubmissionsQueryKey(options)
    });
};

export const quizControllerGetQuizDetailsQueryKey = (options: Options<QuizControllerGetQuizDetailsData>) => createQueryKey('quizControllerGetQuizDetails', options);

/**
 * Get quiz details
 * Retrieves details of a quiz.
 */
export const quizControllerGetQuizDetailsOptions = (options: Options<QuizControllerGetQuizDetailsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await quizControllerGetQuizDetails({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: quizControllerGetQuizDetailsQueryKey(options)
    });
};

export const quizControllerGetQuizAnalyticsQueryKey = (options: Options<QuizControllerGetQuizAnalyticsData>) => createQueryKey('quizControllerGetQuizAnalytics', options);

/**
 * Get quiz analytics
 * Retrieves analytics data for a quiz.
 */
export const quizControllerGetQuizAnalyticsOptions = (options: Options<QuizControllerGetQuizAnalyticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await quizControllerGetQuizAnalytics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: quizControllerGetQuizAnalyticsQueryKey(options)
    });
};

export const quizControllerGetQuizPerformanceQueryKey = (options: Options<QuizControllerGetQuizPerformanceData>) => createQueryKey('quizControllerGetQuizPerformance', options);

/**
 * Get quiz performance statistics
 * Retrieves performance statistics for each question in a quiz.
 */
export const quizControllerGetQuizPerformanceOptions = (options: Options<QuizControllerGetQuizPerformanceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await quizControllerGetQuizPerformance({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: quizControllerGetQuizPerformanceQueryKey(options)
    });
};

export const quizControllerGetQuizResultsQueryKey = (options: Options<QuizControllerGetQuizResultsData>) => createQueryKey('quizControllerGetQuizResults', options);

/**
 * Get quiz results
 * Retrieves results for all students who attempted the quiz.
 */
export const quizControllerGetQuizResultsOptions = (options: Options<QuizControllerGetQuizResultsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await quizControllerGetQuizResults({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: quizControllerGetQuizResultsQueryKey(options)
    });
};

export const quizControllerUpdateQuizSubmissionScoreQueryKey = (options: Options<QuizControllerUpdateQuizSubmissionScoreData>) => createQueryKey('quizControllerUpdateQuizSubmissionScore', options);

/**
 * Override submission score
 * Overrides the score for a specific quiz submission.
 */
export const quizControllerUpdateQuizSubmissionScoreOptions = (options: Options<QuizControllerUpdateQuizSubmissionScoreData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await quizControllerUpdateQuizSubmissionScore({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: quizControllerUpdateQuizSubmissionScoreQueryKey(options)
    });
};

/**
 * Override submission score
 * Overrides the score for a specific quiz submission.
 */
export const quizControllerUpdateQuizSubmissionScoreMutation = (options?: Partial<Options<QuizControllerUpdateQuizSubmissionScoreData>>): UseMutationOptions<unknown, QuizControllerUpdateQuizSubmissionScoreError, Options<QuizControllerUpdateQuizSubmissionScoreData>> => {
    const mutationOptions: UseMutationOptions<unknown, QuizControllerUpdateQuizSubmissionScoreError, Options<QuizControllerUpdateQuizSubmissionScoreData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await quizControllerUpdateQuizSubmissionScore({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const quizControllerRegradeSubmissionQueryKey = (options: Options<QuizControllerRegradeSubmissionData>) => createQueryKey('quizControllerRegradeSubmission', options);

/**
 * Regrade a quiz submission
 * Regrades a quiz submission with new grading results.
 */
export const quizControllerRegradeSubmissionOptions = (options: Options<QuizControllerRegradeSubmissionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await quizControllerRegradeSubmission({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: quizControllerRegradeSubmissionQueryKey(options)
    });
};

/**
 * Regrade a quiz submission
 * Regrades a quiz submission with new grading results.
 */
export const quizControllerRegradeSubmissionMutation = (options?: Partial<Options<QuizControllerRegradeSubmissionData>>): UseMutationOptions<unknown, QuizControllerRegradeSubmissionError, Options<QuizControllerRegradeSubmissionData>> => {
    const mutationOptions: UseMutationOptions<unknown, QuizControllerRegradeSubmissionError, Options<QuizControllerRegradeSubmissionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await quizControllerRegradeSubmission({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const quizControllerAddFeedbackToQuestionQueryKey = (options: Options<QuizControllerAddFeedbackToQuestionData>) => createQueryKey('quizControllerAddFeedbackToQuestion', options);

/**
 * Add feedback to a question in a submission
 * Adds feedback to a specific question in a quiz submission.
 */
export const quizControllerAddFeedbackToQuestionOptions = (options: Options<QuizControllerAddFeedbackToQuestionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await quizControllerAddFeedbackToQuestion({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: quizControllerAddFeedbackToQuestionQueryKey(options)
    });
};

/**
 * Add feedback to a question in a submission
 * Adds feedback to a specific question in a quiz submission.
 */
export const quizControllerAddFeedbackToQuestionMutation = (options?: Partial<Options<QuizControllerAddFeedbackToQuestionData>>): UseMutationOptions<unknown, QuizControllerAddFeedbackToQuestionError, Options<QuizControllerAddFeedbackToQuestionData>> => {
    const mutationOptions: UseMutationOptions<unknown, QuizControllerAddFeedbackToQuestionError, Options<QuizControllerAddFeedbackToQuestionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await quizControllerAddFeedbackToQuestion({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const quizControllerResetAvailableAttemptsQueryKey = (options: Options<QuizControllerResetAvailableAttemptsData>) => createQueryKey('quizControllerResetAvailableAttempts', options);

/**
 * Reset available attempts for a user on a quiz
 * Resets the number of available attempts for a user on a specific quiz.
 */
export const quizControllerResetAvailableAttemptsOptions = (options: Options<QuizControllerResetAvailableAttemptsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await quizControllerResetAvailableAttempts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: quizControllerResetAvailableAttemptsQueryKey(options)
    });
};

/**
 * Reset available attempts for a user on a quiz
 * Resets the number of available attempts for a user on a specific quiz.
 */
export const quizControllerResetAvailableAttemptsMutation = (options?: Partial<Options<QuizControllerResetAvailableAttemptsData>>): UseMutationOptions<unknown, QuizControllerResetAvailableAttemptsError, Options<QuizControllerResetAvailableAttemptsData>> => {
    const mutationOptions: UseMutationOptions<unknown, QuizControllerResetAvailableAttemptsError, Options<QuizControllerResetAvailableAttemptsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await quizControllerResetAvailableAttempts({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const questionBankControllerCreateQueryKey = (options?: Options<QuestionBankControllerCreateData>) => createQueryKey('questionBankControllerCreate', options);

/**
 * Create a new question bank
 * Creates a new question bank for organizing quiz questions.
 */
export const questionBankControllerCreateOptions = (options?: Options<QuestionBankControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await questionBankControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: questionBankControllerCreateQueryKey(options)
    });
};

/**
 * Create a new question bank
 * Creates a new question bank for organizing quiz questions.
 */
export const questionBankControllerCreateMutation = (options?: Partial<Options<QuestionBankControllerCreateData>>): UseMutationOptions<QuestionBankControllerCreateResponse, QuestionBankControllerCreateError, Options<QuestionBankControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<QuestionBankControllerCreateResponse, QuestionBankControllerCreateError, Options<QuestionBankControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await questionBankControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const questionBankControllerGetByIdQueryKey = (options: Options<QuestionBankControllerGetByIdData>) => createQueryKey('questionBankControllerGetById', options);

/**
 * Get question bank by ID
 * Retrieves a question bank and its details by its ID.
 */
export const questionBankControllerGetByIdOptions = (options: Options<QuestionBankControllerGetByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await questionBankControllerGetById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: questionBankControllerGetByIdQueryKey(options)
    });
};

/**
 * Add a question to a question bank
 * Adds a question to the specified question bank.
 */
export const questionBankControllerAddQuestionMutation = (options?: Partial<Options<QuestionBankControllerAddQuestionData>>): UseMutationOptions<QuestionBankControllerAddQuestionResponse, QuestionBankControllerAddQuestionError, Options<QuestionBankControllerAddQuestionData>> => {
    const mutationOptions: UseMutationOptions<QuestionBankControllerAddQuestionResponse, QuestionBankControllerAddQuestionError, Options<QuestionBankControllerAddQuestionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await questionBankControllerAddQuestion({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Remove a question from a question bank
 * Removes a question from the specified question bank.
 */
export const questionBankControllerRemoveQuestionMutation = (options?: Partial<Options<QuestionBankControllerRemoveQuestionData>>): UseMutationOptions<QuestionBankControllerRemoveQuestionResponse, QuestionBankControllerRemoveQuestionError, Options<QuestionBankControllerRemoveQuestionData>> => {
    const mutationOptions: UseMutationOptions<QuestionBankControllerRemoveQuestionResponse, QuestionBankControllerRemoveQuestionError, Options<QuestionBankControllerRemoveQuestionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await questionBankControllerRemoveQuestion({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Replace a question with its duplicate in a question bank
 * Duplicates a question and replaces the original in the question bank.
 */
export const questionBankControllerReplaceQuestionMutation = (options?: Partial<Options<QuestionBankControllerReplaceQuestionData>>): UseMutationOptions<QuestionBankControllerReplaceQuestionResponse, QuestionBankControllerReplaceQuestionError, Options<QuestionBankControllerReplaceQuestionData>> => {
    const mutationOptions: UseMutationOptions<QuestionBankControllerReplaceQuestionResponse, QuestionBankControllerReplaceQuestionError, Options<QuestionBankControllerReplaceQuestionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await questionBankControllerReplaceQuestion({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const attemptControllerAttemptQueryKey = (options: Options<AttemptControllerAttemptData>) => createQueryKey('attemptControllerAttempt', options);

/**
 * Start a new quiz attempt
 * Creates a new attempt for the specified quiz for the current user.
 */
export const attemptControllerAttemptOptions = (options: Options<AttemptControllerAttemptData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await attemptControllerAttempt({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: attemptControllerAttemptQueryKey(options)
    });
};

/**
 * Start a new quiz attempt
 * Creates a new attempt for the specified quiz for the current user.
 */
export const attemptControllerAttemptMutation = (options?: Partial<Options<AttemptControllerAttemptData>>): UseMutationOptions<AttemptControllerAttemptResponse, AttemptControllerAttemptError, Options<AttemptControllerAttemptData>> => {
    const mutationOptions: UseMutationOptions<AttemptControllerAttemptResponse, AttemptControllerAttemptError, Options<AttemptControllerAttemptData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await attemptControllerAttempt({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const attemptControllerSaveQueryKey = (options: Options<AttemptControllerSaveData>) => createQueryKey('attemptControllerSave', options);

/**
 * Save answers for an ongoing attempt
 * Saves the current answers for a quiz attempt without submitting.
 */
export const attemptControllerSaveOptions = (options: Options<AttemptControllerSaveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await attemptControllerSave({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: attemptControllerSaveQueryKey(options)
    });
};

/**
 * Save answers for an ongoing attempt
 * Saves the current answers for a quiz attempt without submitting.
 */
export const attemptControllerSaveMutation = (options?: Partial<Options<AttemptControllerSaveData>>): UseMutationOptions<unknown, AttemptControllerSaveError, Options<AttemptControllerSaveData>> => {
    const mutationOptions: UseMutationOptions<unknown, AttemptControllerSaveError, Options<AttemptControllerSaveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await attemptControllerSave({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const attemptControllerSubmitQueryKey = (options: Options<AttemptControllerSubmitData>) => createQueryKey('attemptControllerSubmit', options);

/**
 * Submit a quiz attempt
 * Submits the answers for a quiz attempt and returns the result.
 */
export const attemptControllerSubmitOptions = (options: Options<AttemptControllerSubmitData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await attemptControllerSubmit({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: attemptControllerSubmitQueryKey(options)
    });
};

/**
 * Submit a quiz attempt
 * Submits the answers for a quiz attempt and returns the result.
 */
export const attemptControllerSubmitMutation = (options?: Partial<Options<AttemptControllerSubmitData>>): UseMutationOptions<AttemptControllerSubmitResponse, AttemptControllerSubmitError, Options<AttemptControllerSubmitData>> => {
    const mutationOptions: UseMutationOptions<AttemptControllerSubmitResponse, AttemptControllerSubmitError, Options<AttemptControllerSubmitData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await attemptControllerSubmit({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const attemptControllerGetAttemptQueryKey = (options: Options<AttemptControllerGetAttemptData>) => createQueryKey('attemptControllerGetAttempt', options);

/**
 * Get details of a quiz attempt
 * Retrieves the details of a specific quiz attempt for the current user.
 */
export const attemptControllerGetAttemptOptions = (options: Options<AttemptControllerGetAttemptData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await attemptControllerGetAttempt({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: attemptControllerGetAttemptQueryKey(options)
    });
};

export const genAiVideoControllerGenerateTranscriptQueryKey = (options?: Options<GenAiVideoControllerGenerateTranscriptData>) => createQueryKey('genAiVideoControllerGenerateTranscript', options);

/**
 * Generate transcript
 */
export const genAiVideoControllerGenerateTranscriptOptions = (options?: Options<GenAiVideoControllerGenerateTranscriptData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await genAiVideoControllerGenerateTranscript({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: genAiVideoControllerGenerateTranscriptQueryKey(options)
    });
};

/**
 * Generate transcript
 */
export const genAiVideoControllerGenerateTranscriptMutation = (options?: Partial<Options<GenAiVideoControllerGenerateTranscriptData>>): UseMutationOptions<unknown, DefaultError, Options<GenAiVideoControllerGenerateTranscriptData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<GenAiVideoControllerGenerateTranscriptData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await genAiVideoControllerGenerateTranscript({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const genAiVideoControllerSegmentTranscriptQueryKey = (options?: Options<GenAiVideoControllerSegmentTranscriptData>) => createQueryKey('genAiVideoControllerSegmentTranscript', options);

/**
 * Segment transcript
 */
export const genAiVideoControllerSegmentTranscriptOptions = (options?: Options<GenAiVideoControllerSegmentTranscriptData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await genAiVideoControllerSegmentTranscript({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: genAiVideoControllerSegmentTranscriptQueryKey(options)
    });
};

/**
 * Segment transcript
 */
export const genAiVideoControllerSegmentTranscriptMutation = (options?: Partial<Options<GenAiVideoControllerSegmentTranscriptData>>): UseMutationOptions<unknown, DefaultError, Options<GenAiVideoControllerSegmentTranscriptData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<GenAiVideoControllerSegmentTranscriptData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await genAiVideoControllerSegmentTranscript({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const genAiVideoControllerGenerateQuestionsQueryKey = (options?: Options<GenAiVideoControllerGenerateQuestionsData>) => createQueryKey('genAiVideoControllerGenerateQuestions', options);

/**
 * Generate questions
 */
export const genAiVideoControllerGenerateQuestionsOptions = (options?: Options<GenAiVideoControllerGenerateQuestionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await genAiVideoControllerGenerateQuestions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: genAiVideoControllerGenerateQuestionsQueryKey(options)
    });
};

/**
 * Generate questions
 */
export const genAiVideoControllerGenerateQuestionsMutation = (options?: Partial<Options<GenAiVideoControllerGenerateQuestionsData>>): UseMutationOptions<unknown, DefaultError, Options<GenAiVideoControllerGenerateQuestionsData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<GenAiVideoControllerGenerateQuestionsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await genAiVideoControllerGenerateQuestions({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const genAiVideoControllerGenerateCourseItemsFromVideoQueryKey = (options?: Options<GenAiVideoControllerGenerateCourseItemsFromVideoData>) => createQueryKey('genAiVideoControllerGenerateCourseItemsFromVideo', options);

/**
 * Generate course items from video
 */
export const genAiVideoControllerGenerateCourseItemsFromVideoOptions = (options?: Options<GenAiVideoControllerGenerateCourseItemsFromVideoData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await genAiVideoControllerGenerateCourseItemsFromVideo({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: genAiVideoControllerGenerateCourseItemsFromVideoQueryKey(options)
    });
};

/**
 * Generate course items from video
 */
export const genAiVideoControllerGenerateCourseItemsFromVideoMutation = (options?: Partial<Options<GenAiVideoControllerGenerateCourseItemsFromVideoData>>): UseMutationOptions<unknown, DefaultError, Options<GenAiVideoControllerGenerateCourseItemsFromVideoData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<GenAiVideoControllerGenerateCourseItemsFromVideoData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await genAiVideoControllerGenerateCourseItemsFromVideo({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const courseSettingsControllerCreateQueryKey = (options?: Options<CourseSettingsControllerCreateData>) => createQueryKey('courseSettingsControllerCreate', options);

/**
 * Create
 */
export const courseSettingsControllerCreateOptions = (options?: Options<CourseSettingsControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseSettingsControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseSettingsControllerCreateQueryKey(options)
    });
};

/**
 * Create
 */
export const courseSettingsControllerCreateMutation = (options?: Partial<Options<CourseSettingsControllerCreateData>>): UseMutationOptions<unknown, DefaultError, Options<CourseSettingsControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<CourseSettingsControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseSettingsControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const courseSettingsControllerGetQueryKey = (options: Options<CourseSettingsControllerGetData>) => createQueryKey('courseSettingsControllerGet', options);

/**
 * Get
 */
export const courseSettingsControllerGetOptions = (options: Options<CourseSettingsControllerGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await courseSettingsControllerGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: courseSettingsControllerGetQueryKey(options)
    });
};

/**
 * Update course settings
 */
export const courseSettingsControllerUpdateCourseSettingsMutation = (options?: Partial<Options<CourseSettingsControllerUpdateCourseSettingsData>>): UseMutationOptions<unknown, DefaultError, Options<CourseSettingsControllerUpdateCourseSettingsData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<CourseSettingsControllerUpdateCourseSettingsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await courseSettingsControllerUpdateCourseSettings({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const userSettingsControllerCreateQueryKey = (options?: Options<UserSettingsControllerCreateData>) => createQueryKey('userSettingsControllerCreate', options);

/**
 * Create
 * Operations for managing user settings in courses
 */
export const userSettingsControllerCreateOptions = (options?: Options<UserSettingsControllerCreateData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await userSettingsControllerCreate({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: userSettingsControllerCreateQueryKey(options)
    });
};

/**
 * Create
 * Operations for managing user settings in courses
 */
export const userSettingsControllerCreateMutation = (options?: Partial<Options<UserSettingsControllerCreateData>>): UseMutationOptions<unknown, DefaultError, Options<UserSettingsControllerCreateData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UserSettingsControllerCreateData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await userSettingsControllerCreate({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const userSettingsControllerGetQueryKey = (options: Options<UserSettingsControllerGetData>) => createQueryKey('userSettingsControllerGet', options);

/**
 * Get
 * Operations for managing user settings in courses
 */
export const userSettingsControllerGetOptions = (options: Options<UserSettingsControllerGetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await userSettingsControllerGet({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: userSettingsControllerGetQueryKey(options)
    });
};

/**
 * Update user settings
 * Operations for managing user settings in courses
 */
export const userSettingsControllerUpdateUserSettingsMutation = (options?: Partial<Options<UserSettingsControllerUpdateUserSettingsData>>): UseMutationOptions<unknown, DefaultError, Options<UserSettingsControllerUpdateUserSettingsData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<UserSettingsControllerUpdateUserSettingsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await userSettingsControllerUpdateUserSettings({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};